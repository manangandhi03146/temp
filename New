import os
import time
import threading
import requests
import pandas as pd

USPS_URL  = "https://apis.usps.com/addresses/v3/address"
TOKEN_URL = "https://apis.usps.com/oauth2/v3/token"

user_csv="csv/Users.csv"
df=pd.read_csv(user_csv)

columns_to_keep=['address1','state', 'country', 'address2' ,'zip' ,'city']
columns_to_drop=df.columns.difference(columns_to_keep)
df=df.drop(columns=columns_to_drop)

df=df.iloc[:10]

html_content="""
<!DOCTYPE html>
<html>
<head>
    <title>Table Viewer</title>
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
    <style>
        body {font-family: Arial, sans-serif;padding:20px;}
        select {padding: 10px;margin-bottom:20px;}
        table { border-collapse: collapse; width: 100%; margin-bottom: 40px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left }
        th { background-color: #f2f2f2; }
        .table-container { display: none; }
    </style>
</head>
"""

# ---------------- helpers & api ----------------
def s(x):
    """Return a clean string (handles NaN/None/ints)."""
    if x is None:
        return ""
    if isinstance(x, float) and pd.isna(x):
        return ""
    return str(x).strip()

def get_token(timeout: float=20.0, retries: int=3)->str:
    url="https://apis.usps.com/oauth2/v3/token"
    payload = {
        "grant_type" : "client_credentials",
        "client_id" : "",          # <-- fill in
        "client_secret" : ""       # <-- fill in
    }
    headers={"Content-Type":"application/json","Accept":"application/json"}
    last_err=None
    for attempt in range(retries):
        try:
            resp=requests.post(url, json=payload, headers=headers, timeout=timeout)
            if resp.status_code==200:
                data=resp.json()
                token=data.get("access_token")
                if not token:
                    raise RuntimeError("No access token in USPS response")
                return token
            if resp.status_code in (429, 500, 502, 503, 504):
                time.sleep(0.5*(2**attempt))
                continue
            last_err=f"HTTP{resp.status_code}: {resp.text[:200]}"
            break
        except Exception as e:
            last_err=str(e)
            time.sleep(0.5*(2**attempt))
    raise RuntimeError(f"Token request failed: {last_err}")

temp_token=get_token()

def dpv_code(res):
    """Return DPV code (Y/D/S/N) regardless of casing/path; else None."""
    if not isinstance(res, dict):
        return None
    parents = ["additionalInfo", "additional_info", "addressMetadata", "metadata"]
    keys = ["DPVConfirmation", "dpvConfirmation", "dpv_confirmation"]
    for p in parents:
        info = res.get(p)
        if isinstance(info, dict):
            for k in keys:
                if k in info and info[k] is not None:
                    return str(info[k]).upper()
    for k in keys:
        if k in res and res[k] is not None:
            return str(res[k]).upper()
    return None

def assess_accuracy(res, orig_a2=""):
    """Return (is_confident: bool, reason: str). Confident = DPV=Y."""
    if not isinstance(res, dict):
        return (False, "no_response")
    code = (dpv_code(res) or "")
    addr = res.get("address", {}) or {}
    zip4 = s(addr.get("ZIPPlus4"))
    sec  = s(addr.get("secondaryAddress"))
    if code == "Y":
        return (True, "DPV=Y (primary+secondary confirmed)")
    if code == "D":
        return (False, "DPV=D (unit missing)" + ("; has ZIP+4" if zip4 else ""))
    if code == "S":
        changed = bool(orig_a2 and not sec)
        return (False, "DPV=S (unit present but unconfirmed)" + ("; secondary dropped" if changed else ""))
    if code == "N":
        return (False, "DPV=N (not deliverable)")
    return (False, "no_dpv_code")

def apply_res(row, res):
    a=(res or {}).get("address",{}) or {}
    row["address1"]=a.get("streetAddress", row.get("address1",""))
    row["address2"]=a.get("secondaryAddress", row.get("address2",""))
    row["city"]=a.get("city", row.get("city",""))
    row["state"]=a.get("state", row.get("state",""))
    row["zip"]=a.get("ZIPCode", row.get("zip",""))
    return row

def usps_lookup(street, secondary=None, city="", state="", zip5="", zip4=None):
    """GET Addresses v3. Return JSON dict on success; None on 400/other failures."""
    street=s(street)
    if not street:
        return None
    try:
        params = {
            "streetAddress": street,
            **({"secondaryAddress": s(secondary)} if secondary else {}),
            **({"city": s(city)} if city else {}),
            **({"state": s(state)} if state else {}),
            **({"ZIPCode": s(zip5)} if zip5 else {}),
            **({"ZIPPlus4": s(zip4)} if zip4 else {}),
        }
        r=requests.get(
            USPS_URL,
            params=params,
            headers={"Authorization" : f"Bearer {temp_token}", "Accept" : "application/json"},
            timeout=15
        )
        if r.status_code==400:
            return None
        if not r.ok:
            return None
        try:
            return r.json()
        except ValueError:
            return None
    except requests.RequestException:
        return None

# ---------------- per-row logic ----------------
df["_debug"] = ""  # ensure the column exists so you can see it

def process_row(row):
    a1 = s(row.get("address1"))
    a2 = s(row.get("address2"))
    city = s(row.get("city"))
    state = s(row.get("state"))
    zip5 = s(row.get("zip"))
    zip4 = s(row.get("zip4")) if "zip4" in row.index else None

    try:
        r1 = usps_lookup(a1, a2 or None, city, state, zip5, zip4)
        ok1, why1 = assess_accuracy(r1, orig_a2=a2)
        if ok1:
            row = apply_res(row, r1)
            row["_debug"] = f"USPS_OK ({why1}) dpv={dpv_code(r1)}"
            return row

        r2 = usps_lookup(a2, None, city, state, zip5, zip4) if a2 else None
        ok2, why2 = assess_accuracy(r2, orig_a2="")
        if ok2:
            row = apply_res(row, r2)
            row["_debug"] = f"USPS_OK_FROM_A2 ({why2}) dpv={dpv_code(r2)}"
            return row

        # fallback
        row["address1"] = a1.upper()
        row["address2"] = a2.upper()
        row["_debug"] = f"FALLBACK_UPPER ({why1} | {why2})"
        return row

    except Exception as e:
        row["_debug"] = f"EXC:{type(e).__name__}: {e}"
        row["address1"] = a1.upper()
        row["address2"] = a2.upper()
        return row

df=df.apply(process_row, axis=1)

html_content +=f"""
    <body>
        <h3>Users</h3>
        {df.to_html(index=False)}
    </body>
    </html>
    """
output_html_file='addresses.html'
with open(output_html_file, 'w') as f:
    f.write(html_content)
